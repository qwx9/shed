diff 84f3b7fe1ef54fe53d4a43036f29f2f42f52a7f7 uncommitted
--- a/main.c
+++ b/main.c
@@ -26,8 +26,6 @@
 
 Mousectl *mctl;
 Keyboardctl *kctl;
-Image *selbg;
-Image *mfg;
 Image *tick;
 Rectangle ir;
 Rectangle sr;
@@ -47,6 +45,16 @@
 int ninput = 0;
 char pwd[255] = {0};
 
+enum{
+	Cbg,
+	Ctext,
+	Chigh,
+	Chtext,
+	Cscrl,
+	Ncols,
+};
+Image *cols[Ncols];
+
 int
 matchcmp(void *a, void *b)
 {
@@ -134,8 +142,8 @@
 {
 	if(loff + i >= nmatches)
 		return;
-	draw(screen, linerect(i), sel ? selbg : display->white, nil, ZP);
-	string(screen, addpt(lr.min, Pt(0, i * lh)), display->black, ZP, font, matches[loff + i].name);
+	draw(screen, linerect(i), cols[sel ? Chigh : Cbg], nil, ZP);
+	string(screen, addpt(lr.min, Pt(0, i * lh)), cols[sel ? Chtext : Ctext], ZP, font, matches[loff + i].name);
 }
 
 void
@@ -146,13 +154,13 @@
 	Rectangle r, scrposr;
 	int i, h, y, ye;
 
-	draw(screen, screen->r, display->white, nil, ZP);
-	p = string(screen, addpt(screen->r.min, Pt(Padding, Padding)), display->black, ZP, font, "> ");
-	p = stringn(screen, p, display->black, ZP, font, input, ninput);
+	draw(screen, screen->r, cols[Cbg], nil, ZP);
+	p = string(screen, addpt(screen->r.min, Pt(Padding, Padding)), cols[Ctext], ZP, font, "> ");
+	p = stringn(screen, p, cols[Ctext], ZP, font, input, ninput);
 	r = Rect(p.x, p.y, p.x + Dx(tick->r), p.y + Dy(tick->r));
 	draw(screen, r, tick, nil, ZP);
-	draw(screen, sr, mfg, nil, ZP);
-	border(screen, sr, 0, display->black, ZP);
+	draw(screen, sr, cols[Cscrl], nil, ZP);
+	border(screen, sr, 0, cols[Ctext], ZP);
 	if(nmatches > 0){
 		h = ((double)lcount / nmatches) * Dy(sr);
 		y = ((double)loff / nmatches) * Dy(sr);
@@ -162,13 +170,13 @@
 		scrposr = Rect(sr.min.x + 1, sr.min.y + y + 1, sr.max.x - 1, ye);
 	}else
 		scrposr = insetrect(sr, -1);
-	draw(screen, scrposr, display->white, nil, ZP);
+	draw(screen, scrposr, cols[Cbg], nil, ZP);
 	for(i = 0; i < lcount; i++)
 		drawline(i, i == lsel);
 	i = snprint(b, sizeof b, "%d/%d", nmatches, nlines);
 	b[i] = 0;
 	p = Pt(screen->r.max.x - Padding - stringwidth(font, b), screen->r.min.y + Padding);
-	string(screen, p, mfg, ZP, font, b);
+	string(screen, p, cols[Cscrl], ZP, font, b);
 	flushimage(display, 1);
 }
 
@@ -363,16 +371,16 @@
 {
 	Image *t;
 
-	t = allocimage(display, Rect(0, 0, Tickw, font->height), screen->chan, 0, DWhite);
+	t = allocimage(display, Rect(0, 0, Tickw, font->height), screen->chan, 0, DNofill);
 	if(t == nil)
 		return 0;
 	/* background color */
-	draw(t, t->r, display->white, nil, ZP);
+	draw(t, t->r, cols[Cbg], nil, ZP);
 	/* vertical line */
-	draw(t, Rect(Tickw/2, 0, Tickw/2+1, font->height), display->black, nil, ZP);
+	draw(t, Rect(Tickw/2, 0, Tickw/2+1, font->height), cols[Ctext], nil, ZP);
 	/* box on each end */
-	draw(t, Rect(0, 0, Tickw, Tickw), display->black, nil, ZP);
-	draw(t, Rect(0, font->height-Tickw, Tickw, font->height), display->black, nil, ZP);
+	draw(t, Rect(0, 0, Tickw, Tickw), cols[Ctext], nil, ZP);
+	draw(t, Rect(0, font->height-Tickw, Tickw, font->height), cols[Ctext], nil, ZP);
 	return t;
 }
 
@@ -386,6 +394,7 @@
 void
 threadmain(int argc, char **argv)
 {
+	int i;
 	Mouse m;
 	Rune k;
 	Alt a[] = {
@@ -420,9 +429,19 @@
 	a[Emouse].c = mctl->c;
 	a[Eresize].c = mctl->resizec;
 	a[Ekeyboard].c = kctl->c;
+
+	Theme th[Ncols] = {
+		[Cbg] { "back",		DWhite },
+		[Ctext]	{ "text",	DBlack },
+		[Chigh] { "high",	0xEFEFEFFF },
+		[Chtext]{ "htext",	DBlack },
+		[Cscrl]	{ "border",	0x999999FF },
+	};
+	readtheme(th, nelem(th), nil);
+	for(i=0; i<Ncols; i++)
+ 		cols[i] = allocimage(display, Rect(0,0,1,1), screen->chan, 1, th[i].c);
+
 	tick = createtick();
-	selbg = allocimage(display, Rect(0,0,1,1), screen->chan, 1, 0xEFEFEFFF);
-	mfg = allocimage(display, Rect(0,0,1,1), screen->chan, 1, 0x999999FF);
 	loff = 0;
 	lsel = 0;
 	eresize();
